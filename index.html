<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Content Hub</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/styles/main.css">
    <style>
        /* General body styles are in main.css */
        /* These styles are specific to the layout of index.html */
        body {
            /* font-family is inherited from main.css */
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden; /* Prevent body scrollbars */
            /* transition for margin-left is here, background/color transitions are in main.css */
            transition: margin-left 0.3s ease-in-out; 
        }

        #sidebar-toggle-btn {
            position: fixed; /* Or absolute if sidebar is the parent */
            top: 10px;
            left: 10px; /* Initial position */
            z-index: 1001; /* Above sidebar */
            background-color: var(--button-background);
            color: var(--button-text);
            border: 1px solid var(--border-color); /* Use var for border */
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
            transition: left 0.3s ease-in-out, background-color 0.3s ease, color 0.3s ease;
        }

        #sidebar {
            width: 250px;
            min-width: 250px; /* Prevent it from shrinking too much during transition */
            background-color: var(--sidebar-background);
            color: var(--sidebar-text); /* Added text color for sidebar */
            padding: 20px;
            padding-top: 50px; /* Space for the toggle button if it were inside */
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            height: 100%;
            position: fixed; /* Changed to fixed for proper off-screen sliding */
            left: 0;
            top: 0;
            z-index: 1000;
            transform: translateX(0);
            transition: transform 0.3s ease-in-out, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        #sidebar.sidebar-collapsed {
            transform: translateX(-100%);
            border-right: none; /* Hide border when collapsed */
        }

        #content-area {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto; /* Keep this if content within iframe might scroll */
            height: 100%;
            margin-left: 270px; 
            transition: margin-left 0.3s ease-in-out;
            display: flex; /* Make content-area a flex container */
            flex-direction: column; /* Stack children vertically */
            box-sizing: border-box; /* Ensure padding is included in height calculation */
            background-color: var(--background-color); /* Ensure content area also uses theme */
        }

        body.sidebar-collapsed #content-area {
            margin-left: 20px; /* Adjust as needed, or 0 if toggle button moves with content */
        }
        
        body.sidebar-collapsed #sidebar-toggle-btn {
            left: 10px; /* Keep button visible */
        }

        #toc-container h2 {
            margin-top: 0;
            color: var(--sidebar-text); /* Theme TOC header */
        }
        #navigation-area h3 {
             color: var(--sidebar-text); /* Theme Navigation header */
        }


        #home-content { /* Added style for home-content */
            flex-grow: 1; /* Allow home-content to fill available space in content-area */
            position: relative; 
        }

        #home-content iframe { /* More specific selector and adjusted height */
            width: 100%;
            height: 100%; /* Fill the #home-content div */
            border: 1px solid var(--iframe-border-color);
            box-sizing: border-box;
        }

        .hidden {
            display: none;
        }
        #navigation-area button.active {
            background-color: var(--secondary-color); /* Use a theme variable */
            font-weight: bold;
            /* color will be var(--button-text) or overridden if needed */
        }
        #theme-toggle-btn { /* Style for the new theme toggle button */
            display: block; /* Make it take full width in its container */
            width: calc(100% - 16px); /* Adjust width considering padding */
            margin: 10px auto; /* Center it and add some margin */
            padding: 10px;
            /* background-color, color, border are inherited from general button styles or overridden by main.css vars */
        }

        /* Quality Control Button & Modal Styles */
        #qc-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--accent-color, #007bff);
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #qc-button:hover {
            background: var(--accent-hover-color, #0056b3);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        #qc-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #qc-modal-content {
            background: var(--bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            position: relative;
        }

        #qc-modal-header {
            padding: 20px;
            background: var(--secondary-bg-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #qc-modal-header h3 {
            margin: 0;
            font-size: 18px;
            color: var(--text-color);
        }

        #qc-close-button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-color);
            padding: 0;
            line-height: 1;
        }

        #qc-close-button:hover {
            color: var(--accent-color, #007bff);
        }

        #qc-modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
        }

        .qc-summary {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--secondary-bg-color);
            border-radius: 8px;
            border-left: 4px solid var(--accent-color, #007bff);
        }

        .qc-section {
            margin-bottom: 15px;
        }

        .qc-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .qc-test-item {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .qc-test-pass { background: #d4edda; color: #155724; }
        .qc-test-fail { background: #f8d7da; color: #721c24; }
        .qc-test-warn { background: #fff3cd; color: #856404; }
    </style>
    </head>
<body>
    <!-- Quality Control Button -->
    <button id="qc-button" title="Quality Control Report">üìä</button>
    
    <!-- Quality Control Modal -->
    <div id="qc-modal">
        <div id="qc-modal-content">
            <div id="qc-modal-header">
                <h3>üìä Quality Control Report</h3>
                <button id="qc-close-button">&times;</button>
            </div>
            <div id="qc-modal-body">
                <div class="qc-summary" id="qc-summary">
                    <strong>Initializing quality control tests...</strong>
                </div>
                <div id="qc-details"></div>
            </div>
        </div>
    </div>

    <button id="sidebar-toggle-btn">‚ò∞</button>
    <!-- Quality Control will be loaded dynamically to avoid path conflicts -->
    <script>
        // Authentication Check and Redirection
        (function() {
            // console.log("Checking authentication status..."); // Log can be removed or kept
            const isAuthenticated = sessionStorage.getItem('isAuthenticated');
            if (isAuthenticated !== 'true') {
                // Optional: Store the page they were trying to access to redirect back later
                // sessionStorage.setItem('redirectUrl', window.location.pathname + window.location.search);
                window.location.href = 'login.html';
            }
        })();
    </script>

    <div id="sidebar">
        <div> <!-- Wrapper for theme button -->
            <button id="theme-toggle-btn">Toggle Theme</button>
        </div>
        <hr>
        <div id="search-container" style="padding: 10px 0;">
            <input type="search" id="toc-search" placeholder="Search content..." style="width: 100%; box-sizing: border-box; padding: 8px;">
        </div>
        <hr>
        <div id="toc-container">
            <h2>Table of Contents</h2>
            <div id="dynamic-toc-content">
                <!-- toc.html will be loaded here -->
                <p>Loading Table of Contents...</p> 
            </div>
            <!-- Removed extra closing div from here -->
        </div>
    </div>
    <div id="content-area">
        <div id="home-content">
            <!-- Iframe will be created here by JavaScript -->
        </div>
    </div>

    <script>
        // CORS FALLBACK IMPLEMENTATIONS FOR FILE:// PROTOCOL
        // These provide basic functionality when ES modules can't be loaded
        
        // Fallback environment configuration
        window.envConfigFallback = {
            environment: 'development',
            baseUrl: '/',
            authConfig: {
                tier: 1,
                password: 'TEST_PROJECT',
                passwordHash: 'c44267c8b6a0f19268d96cfd59aa6a42b6ad7571f35bfa6752dce77e04922673',
                sessionKey: 'tier0Password'
            }
        };

        // Fallback AutoStorage implementation
        window.AutoStorageFallback = class {
            constructor() {
                this.initialized = false;
            }
            
            async init() {
                if (this.initialized) return;
                this.initialized = true;
                console.info("AutoStorage fallback initialized");
            }
            
            saveState() { /* Basic localStorage operations */ }
            loadState() { /* Basic localStorage operations */ }
        };

        // Fallback Quality Control implementation
        window.QualityControllerFallback = class {
            constructor() {
                this.errors = [];
                this.warnings = [];
                this.tests = [];
            }
            
            async runAllTests() {
                this.tests.push({
                    name: 'Fallback Mode Active',
                    status: 'INFO',
                    details: 'Running in fallback mode due to CORS restrictions'
                });
                return { errors: this.errors, warnings: this.warnings, tests: this.tests };
            }
            
            generateReport() {
                return {
                    summary: 'Fallback mode active - limited functionality',
                    timestamp: new Date().toISOString(),
                    errors: this.errors,
                    warnings: this.warnings,
                    tests: this.tests
                };
            }
        };

        // Fallback Content Diagnostics implementation
        window.ContentLoadingDiagnosticsFallback = class {
            constructor() {
                this.debugMode = true;
            }
            
            log(message, level = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
            }
            
            async loadContentWithDiagnostics(pageUrl, buttonElementToActivate) {
                this.log(`üîÑ Loading content (fallback): ${pageUrl}`, 'info');
                return window.basicLoadContent(pageUrl, buttonElementToActivate);
            }
            
            createEnhancedIframe() {
                const iframe = document.createElement('iframe');
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms');
                return iframe;
            }
        };

        // Enhanced module loading with CORS fallback
        async function loadModuleWithFallback(modulePath, fallbackObject) {
            try {
                // Try to load ES module
                const module = await import(modulePath);
                console.log(`‚úÖ Loaded ES module: ${modulePath}`);
                return module.default || module;
            } catch (error) {
                if (error.message.includes('CORS') || error.message.includes('file://')) {
                    console.warn(`üîÑ CORS restriction detected for ${modulePath}, using fallback`);
                    return fallbackObject;
                } else {
                    console.error(`‚ùå Failed to load ${modulePath}:`, error);
                    return fallbackObject;
                }
            }
        }

        // Enhanced initialization with fallback support
        async function initializeWithFallbacks() {
            console.log('üöÄ Initializing application with CORS fallback support...');
            
            try {
                // Load content diagnostics with fallback
                const diagnosticsModule = await loadModuleWithFallback(
                    './src/content-diagnostics.js', 
                    window.ContentLoadingDiagnosticsFallback
                );
                
                if (typeof diagnosticsModule === 'function') {
                    window.contentDiagnostics = new diagnosticsModule();
                } else if (diagnosticsModule && diagnosticsModule.ContentLoadingDiagnostics) {
                    window.contentDiagnostics = new diagnosticsModule.ContentLoadingDiagnostics();
                } else {
                    window.contentDiagnostics = new window.ContentLoadingDiagnosticsFallback();
                }
                
                console.log('‚úÖ Content diagnostics initialized');
                
                // Try to load other modules with fallbacks
                const configModule = await loadModuleWithFallback(
                    './src/env-config.js',
                    window.envConfigFallback
                );
                
                // Make config globally accessible
                window.envConfig = configModule;
                
                const autoStorageModule = await loadModuleWithFallback(
                    './src/auto-storage.js',
                    window.AutoStorageFallback
                );
                
                if (typeof autoStorageModule === 'function') {
                    window.autoStorage = new autoStorageModule();
                } else if (autoStorageModule && autoStorageModule.AutoStorage) {
                    window.autoStorage = new autoStorageModule.AutoStorage();
                } else {
                    window.autoStorage = new window.AutoStorageFallback();
                }
                
                await window.autoStorage.init();
                
                const qcModule = await loadModuleWithFallback(
                    './src/quality-control.js',
                    window.QualityControllerFallback
                );
                
                if (typeof qcModule === 'function') {
                    window.qualityController = new qcModule();
                } else if (qcModule && qcModule.QualityController) {
                    window.qualityController = new qcModule.QualityController();
                } else {
                    window.qualityController = new window.QualityControllerFallback();
                }
                
                console.log('‚úÖ All modules initialized successfully');
                
                // Run initial QC check
                setTimeout(() => {
                    runQualityCheck();
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
                // Ensure basic functionality works even if everything fails
                window.contentDiagnostics = new window.ContentLoadingDiagnosticsFallback();
                window.autoStorage = new window.AutoStorageFallback();
                window.qualityController = new window.QualityControllerFallback();
                await window.autoStorage.init();
            }
        }

        // Quality Control runner function
        async function runQualityCheck() {
            try {
                if (window.qualityController) {
                    // Update modal content to show running status
                    const qcSummary = document.getElementById('qc-summary');
                    const qcDetails = document.getElementById('qc-details');
                    
                    if (qcSummary) {
                        qcSummary.innerHTML = '<strong>üîÑ Running quality control tests...</strong>';
                    }
                    if (qcDetails) {
                        qcDetails.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">Please wait while tests are executed...</div>';
                    }
                    
                    // Run QC tests and update the modal UI
                    await window.qualityController.runAllTests();
                    if (window.qualityController.updateModalReport) {
                        window.qualityController.updateModalReport();
                    }
                    console.log('‚úÖ Quality Control tests completed');
                } else {
                    // Show error in modal
                    const qcSummary = document.getElementById('qc-summary');
                    if (qcSummary) {
                        qcSummary.innerHTML = '<strong style="color: #721c24;">‚ö†Ô∏è Quality Controller not available</strong>';
                    }
                    console.warn('‚ö†Ô∏è Quality Controller not available');
                }
            } catch (error) {
                // Show error in modal
                const qcSummary = document.getElementById('qc-summary');
                if (qcSummary) {
                    qcSummary.innerHTML = `<strong style="color: #721c24;">‚ùå QC tests failed: ${error.message}</strong>`;
                }
                console.warn('‚ö†Ô∏è QC tests failed:', error);
            }
        }

        // Enhanced basic content loading function
        async function basicLoadContent(pageUrl, buttonElementToActivate) {
            console.log(`üîÑ [Basic] Loading content: ${pageUrl}`);
            
            const homeContentDiv = document.getElementById('home-content');
            if (!homeContentDiv) {
                console.error('[Basic] Home content area (home-content) not found.');
                return false;
            }

            const navButtons = document.querySelectorAll('#navigation-area button');
            navButtons.forEach(btn => btn.classList.remove('active'));

            if (buttonElementToActivate) {
                buttonElementToActivate.classList.add('active');
            }

            let iframe = homeContentDiv.querySelector('iframe');
            if (!iframe) {
                iframe = document.createElement('iframe');
                iframe.id = 'content-iframe';
                iframe.style.cssText = 'width: 100%; height: 100%; border: none; background: white; min-height: 500px;';
                
                // Enhanced error handling for iframe loading
                iframe.onerror = function() {
                    console.error('[Basic] Failed to load content:', pageUrl);
                    const errorHtml = `
                        <html><body style="font-family: Arial; padding: 20px; text-align: center;">
                            <h3>Content not available</h3>
                            <p>Unable to load: ${pageUrl}</p>
                            <button onclick="window.location.reload()">Retry</button>
                        </body></html>
                    `;
                    iframe.src = 'data:text/html;charset=utf-8,' + encodeURIComponent(errorHtml);
                };
                
                // Improved iframe load handling
                iframe.onload = function() {
                    console.log('‚úÖ [Basic] Content loaded:', pageUrl);
                    try {
                        // Enhanced cross-origin error suppression
                        if (iframe.contentWindow) {
                            iframe.contentWindow.addEventListener('error', function(e) {
                                console.warn('üîá [Basic] Iframe error suppressed:', e.message);
                                return true;
                            });
                        }
                    } catch (e) {
                        // Cross-origin restrictions - this is expected and normal
                    }
                };
                
                homeContentDiv.innerHTML = ''; 
                homeContentDiv.appendChild(iframe);
            }
            
            // Validate and set URL
            if (pageUrl && pageUrl.trim() && !pageUrl.includes('<') && !pageUrl.includes('javascript:')) {
                console.log('üîÑ [Basic] Loading:', pageUrl);
                
                // Pre-flight check
                try {
                    const response = await fetch(pageUrl, { method: 'HEAD' });
                    if (response.ok) {
                        iframe.src = pageUrl;
                        return true;
                    } else {
                        console.error('‚ùå [Basic] File not found:', pageUrl, response.status);
                        iframe.src = `data:text/html,<html><body style="font-family: Arial; padding: 20px; text-align: center;"><h3>File Not Found</h3><p>${pageUrl} (HTTP ${response.status})</p></body></html>`;
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå [Basic] Network error:', error.message);
                    iframe.src = `data:text/html,<html><body style="font-family: Arial; padding: 20px; text-align: center;"><h3>Network Error</h3><p>${error.message}</p></body></html>`;
                    return false;
                }
            } else {
                console.error('[Basic] Invalid page URL:', pageUrl);
                iframe.src = `data:text/html,<html><body style="font-family: Arial; padding: 20px; text-align: center;"><h3>Invalid URL</h3><p>Invalid URL provided: ${pageUrl || 'undefined'}</p></body></html>`;
                return false;
            }
        };

        // Import the content diagnostics system
        let contentDiagnostics;
        
        // Initialize all modules with CORS fallback support when DOM is ready
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeWithFallbacks();
        });

        // Enhanced core function to load content into the iframe
        window.loadContent = async function(pageUrl, buttonElementToActivate) {
            console.log(`üîÑ Loading content: ${pageUrl}`);
            
            // Try to use diagnostics system if available
            if (window.contentDiagnostics && window.contentDiagnostics.loadContentWithDiagnostics) {
                try {
                    return await window.contentDiagnostics.loadContentWithDiagnostics(pageUrl, buttonElementToActivate);
                } catch (error) {
                    console.warn('‚ö†Ô∏è Diagnostics system failed, using basic loading:', error.message);
                    // Fall through to basic implementation
                }
            }
            
            // Basic implementation (used as fallback or when diagnostics unavailable)
            return await basicLoadContent(pageUrl, buttonElementToActivate);
        };

        // Function for static navigation buttons in the sidebar
        window.showContent = function(pageKey) {
            // This function is now effectively deprecated as static nav buttons are removed.
            // However, it's kept for potential future use or if any part of the app still calls it.
            // The default page load is handled by the 'Initial page load logic' block.
            console.warn('window.showContent is deprecated. Navigation should occur via TOC.', pageKey);
            // Default behavior could be to load the first item from TOC or a specific known page.
            // For now, let's make it load the introduction page if 'home' is requested.
            if (pageKey === 'home') {
                 // Attempt to find "INTRODUCTION" in toc.html and load it
                const introLink = document.querySelector('#dynamic-toc-content a[href*="introduction/page.html"]');
                if (introLink && introLink.href) {
                    window.loadContentIntoIframe(introLink.getAttribute('href'), introLink);
                } else {
                     // Fallback if intro link not found, load a default known page from EXPRESS.
                     // This should ideally match one of the preferredOrder items.
                     window.loadContentIntoIframe('EXPRESS/introduction/page.html', null);
                }
            } else if (pageKey === 'test') { // 'test' key is also deprecated
                 // Attempt to find "COMPREHENSIVE STORAGE TEST" in toc.html and load it
                const testLink = document.querySelector('#dynamic-toc-content a[href*="comprehensive-storage-test/index.html"]');
                if (testLink && testLink.href) {
                    window.loadContentIntoIframe(testLink.getAttribute('href'), testLink);
                } else {
                    window.loadContentIntoIframe('EXPRESS/comprehensive-storage-test/index.html', null);
                }
            } else {
                console.warn('showContent called with unknown or unhandled pageKey:', pageKey);
            }
        };

        // Function called by toc.html links (e.g., parent.loadContentIntoIframe('path/to/page.html', this))
        window.loadContentIntoIframe = function(pageUrl, tocLinkElement) {
            // Simple routing with history management
            const route = extractRouteFromUrl(pageUrl);
            const newUrl = new URL(window.location);
            newUrl.hash = route;
            window.history.pushState({ page: pageUrl, route: route }, '', newUrl);
            
            window.loadContent(pageUrl, null); 
            sessionStorage.setItem('currentPage', pageUrl);
        };
        
        // Helper function to extract route from URL
        function extractRouteFromUrl(url) {
            // Convert EXPRESS/section/page.html to #/section
            let route = url.replace(/^EXPRESS\//, '').replace(/\/index\.html$/, '').replace(/\/page\.html$/, '');
            if (!route || route === url) {
                // Fallback for other patterns
                const parts = url.split('/').filter(part => part && part !== 'EXPRESS');
                route = parts.length > 0 ? parts.join('/') : 'home';
            }
            return route;
        }
        
        // Enhanced handle URL routing for direct access and browser navigation
        async function handleRouting() {
            // Simple routing without complex router dependency
            const hash = window.location.hash.slice(1); // Remove # 
            if (!hash) {
                return false; // No hash to process
            }
            
            console.log('üîç Processing URL hash:', hash);
            
            // Try to find content based on hash with more comprehensive path mapping
            const possiblePaths = [
                `EXPRESS/${hash}/index.html`,     // Try index.html first (most common)
                `EXPRESS/${hash}/page.html`,      // Then page.html
                `EXPRESS/${hash}.html`            // Finally direct .html file
            ];
            
            // Try each possible path sequentially and wait for responses
            for (const path of possiblePaths) {
                try {
                    console.log('üîç Trying path:', path);
                    const response = await fetch(path, { method: 'HEAD' });
                    if (response.ok) {
                        console.log('‚úÖ Found content at:', path);
                        const success = await window.loadContent(path, null);
                        if (success) {
                            sessionStorage.setItem('currentPage', path);
                            return true;
                        }
                    }
                } catch (error) {
                    // Continue to next path
                    console.debug(`Path not accessible: ${path}`, error.message);
                }
            }
            
            console.log('‚ùå No content found for hash:', hash);
            return false;
        }

        // Enhanced navigation event handlers
        window.addEventListener('hashchange', async function() {
            console.log('üîÑ Hash changed, handling routing...');
            await handleRouting();
        });
        
        // Handle initial routing if URL has hash
        if (window.location.hash) {
          setTimeout(async () => {
            console.log('üîÑ Initial hash detected, handling routing...');
            await handleRouting();
          }, 100);
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.page) {
                window.loadContent(event.state.page, null);
                sessionStorage.setItem('currentPage', event.state.page);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            // Theme Toggle Functionality
            const themeToggleButton = document.getElementById('theme-toggle-btn');
            // const body = document.body; // Define body inside DOMContentLoaded or pass to applyTheme
            // const iframe = document.querySelector('#home-content iframe'); // Get iframe reference early

            function applyTheme(theme) {
                // Ensure document.body is available before proceeding.
                if (!document.body) { 
                    console.error('Theme application (DOMContentLoaded): document.body is not available.');
                    return; 
                }
                // If document.documentElement is also styled by this function, check it too:
                // if (!document.documentElement) {
                //     console.error('Theme application (DOMContentLoaded): document.documentElement is not available.');
                //     return;
                // }

                const newTheme = theme === 'dark' ? 'dark' : 'light';

                // Apply to body
                if (newTheme === 'dark') {
                    document.body.classList.add('dark-theme');
                } else {
                    document.body.classList.remove('dark-theme');
                }
                
                // If you also want to manage classes on document.documentElement from here:
                // For example, if the main.css expects html.dark-theme for some global styles
                if (document.documentElement) {
                   if (newTheme === 'dark') {
                       document.documentElement.classList.add('dark-theme'); // Optional: if your CSS uses html.dark-theme
                   } else {
                       document.documentElement.classList.remove('dark-theme'); // Optional
                   }
                }

                localStorage.setItem('theme', newTheme);

                const contentIframe = document.querySelector('#home-content iframe');
                if (contentIframe && contentIframe.contentWindow) {
                    contentIframe.contentWindow.postMessage({ type: 'themeChange', theme: newTheme }, '*');
                }
            }

            // Initial theme application based on localStorage (MOVED HERE - though already here, adding try/catch)
            try {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    applyTheme(savedTheme);
                } else {
                    applyTheme('light'); // Default
                }
            } catch (e) {
                console.warn('Failed to apply theme from localStorage on DOMContentLoaded (root index.html):', e);
                applyTheme('light'); // Fallback
            }

            themeToggleButton.addEventListener('click', function() {
                const currentTheme = localStorage.getItem('theme') === 'dark' ? 'dark' : 'light';
                applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
            });

            /*
            const tocTargetDiv = document.getElementById('dynamic-toc-content');

            if (typeof window.envConfig === 'undefined') {
                if (tocTargetDiv) {
                    tocTargetDiv.innerHTML = '<p style="color: red; font-weight: bold;">Critical Error: The environment configuration file (src/env-config.js) failed to load. This may be due to a server error (e.g., file not found, incorrect MIME type for JavaScript) or a syntax error in the file itself. The application cannot proceed reliably. Please check the browser console for errors related to \'src/env-config.js\'.</p>';
                } else {
                    console.error('Error: Target div for ToC (dynamic-toc-content) not found, and envConfig also failed to load.');
                }
                const searchInput = document.getElementById('toc-search');
                if(searchInput) searchInput.disabled = true;
                const homeContentDiv = document.getElementById('home-content');
                if(homeContentDiv) homeContentDiv.innerHTML = '<p style="padding:20px; color:red;">Content loading suspended due to configuration error.</p>';

            } else {
                // envConfig is loaded, proceed to load TOC
                if (tocTargetDiv) {
                    fetch('toc.html')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok for toc.html: ' + response.status + ' ' + response.statusText);
                            }
                            return response.text();
                        })
                        .then(html => {
                            tocTargetDiv.innerHTML = html;
                            // Add event delegation for ToC links AFTER content is loaded
                            tocTargetDiv.addEventListener('click', function(event) {
                                let targetElement = event.target;
                                // Traverse up the DOM to find an anchor tag if the click was on a child element (e.g., <span> inside <a>)
                                while (targetElement && targetElement !== this && targetElement.tagName !== 'A') {
                                    targetElement = targetElement.parentElement;
                                }

                                if (targetElement && targetElement.tagName === 'A' && targetElement.hasAttribute('href')) {
                                    event.preventDefault(); // Prevent full page navigation
                                    const pageUrl = targetElement.getAttribute('href'); 
                                    if (pageUrl) {
                                        // Call the existing function designed for ToC links
                                        window.loadContentIntoIframe(pageUrl, targetElement);
                                    }
                                }
                            });
                        })
                        .catch(error => {
                            console.error('Error loading Table of Contents:', error);
                            if (tocTargetDiv) {
                               tocTargetDiv.innerHTML = '<p style="color: red;">Error loading Table of Contents. See console for details.</p>';
                            }
                        });
                } else {
                    console.error('Error: Target div for ToC (dynamic-toc-content) not found.');
                }
                
                // Initial page load logic
                const lastPage = sessionStorage.getItem('currentPage');
                if (lastPage) {
                    window.loadContent(lastPage, null); 
                } else {
                    // Wait for TOC to potentially load to find the intro link
                    // A slight delay or a more robust check might be needed if toc.html fetch is slow
                    // For now, assuming querySelector will find it if toc.html is processed quickly
                    setTimeout(() => { // Adding a minimal delay to allow TOC to render
                        const introLink = document.querySelector('#dynamic-toc-content a[href*="introduction/page.html"]');
                        if (introLink && introLink.href) {
                            window.loadContentIntoIframe(introLink.getAttribute('href'), introLink);
                        } else {
                             window.loadContent('EXPRESS/introduction/page.html', null); // Fallback if introLink not found
                        }
                    }, 100); // 100ms delay, adjust as needed or use MutationObserver for robustness
                }
            }
            */
            // Sidebar Toggle Functionality
            const sidebar = document.getElementById('sidebar');
            const toggleButton = document.getElementById('sidebar-toggle-btn');
            if (sidebar && toggleButton) {
                const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
                if (isCollapsed) {
                    document.body.classList.add('sidebar-collapsed');
                    sidebar.classList.add('sidebar-collapsed');
                }

                toggleButton.addEventListener('click', function() {
                    sidebar.classList.toggle('sidebar-collapsed');
                    document.body.classList.toggle('sidebar-collapsed');
                    localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('sidebar-collapsed'));
                });
            } else {
                console.error('Sidebar or toggle button element not found. Toggle functionality will not work.');
            }

            // TOC Search Functionality
            const searchInput = document.getElementById('toc-search');
            const tocContentDiv = document.getElementById('dynamic-toc-content');

            searchInput.addEventListener('input', function(event) {
                const searchTerm = event.target.value.toUpperCase();

                if (!tocContentDiv.querySelector('ul')) {
                    return; 
                }

                const allTopLevelLi = tocContentDiv.querySelectorAll(':scope > ul > li');

                allTopLevelLi.forEach(mainLi => {
                    let mainLiVisible = false;
                    const mainLink = mainLi.querySelector(':scope > a, :scope > span'); 
                    
                    if (mainLink && mainLink.textContent.toUpperCase().includes(searchTerm)) {
                        mainLiVisible = true;
                    }

                    const subUl = mainLi.querySelector(':scope > ul');
                    let hasVisibleSubItem = false;
                    if (subUl) {
                        const allSubLevelLi = subUl.querySelectorAll(':scope > li');
                        allSubLevelLi.forEach(subLi => {
                            const subLink = subLi.querySelector(':scope > a');
                            if (subLink && subLink.textContent.toUpperCase().includes(searchTerm)) {
                                subLi.style.display = ''; 
                                hasVisibleSubItem = true;
                            } else {
                                subLi.style.display = 'none'; 
                            }
                        });
                    }

                    if (mainLiVisible || hasVisibleSubItem) {
                        mainLi.style.display = ''; 
                        if (subUl) subUl.style.display = ''; 
                    } else {
                        mainLi.style.display = 'none'; 
                    }
                });
            });

            // Ensure iframe gets theme on initial load if it's already there
            // This is a bit redundant if loadContent also triggers it, but good for safety
            const contentIframe = document.querySelector('#home-content iframe');
            if (contentIframe && contentIframe.contentWindow) {
                 const currentTheme = localStorage.getItem('theme') || 'light';
                 contentIframe.onload = function() { // Ensure iframe is loaded before sending message
                    contentIframe.contentWindow.postMessage({ type: 'themeChange', theme: currentTheme }, '*');
                 };
                 // If iframe is already loaded (e.g. navigating back), send message directly
                 if (contentIframe.contentDocument && contentIframe.contentDocument.readyState === 'complete') {
                    contentIframe.contentWindow.postMessage({ type: 'themeChange', theme: currentTheme }, '*');
                 }
            }
        });
    </script>
    <script type="module">
      async function loadConfigAndInitialize() {
        const tocTargetDiv = document.getElementById('dynamic-toc-content');
        const homeContentDiv = document.getElementById('home-content');
        const searchInput = document.getElementById('toc-search');
        // const initialLoadLogicContainer = document.getElementById('initial-page-load-logic-container'); // Assuming you move initial load logic here

        function showFatalError(message) {
          if (tocTargetDiv) tocTargetDiv.innerHTML = `<p style="color: red; font-weight: bold;">${message}</p>`;
          if (homeContentDiv) homeContentDiv.innerHTML = `<p style="padding:20px; color:red;">Application failed to initialize: ${message}</p>`;
          if (searchInput) searchInput.disabled = true;
          // Consider disabling other interactive elements too, like theme toggle
          const themeToggleButton = document.getElementById('theme-toggle-btn');
          if (themeToggleButton) themeToggleButton.disabled = true;
        }

        // Modules are already initialized via initializeWithFallbacks() in DOMContentLoaded
        // Just ensure they're available and run initial setup
        
        // Clear any previous error shown in TOC area if it was there from a different script
        if (tocTargetDiv && tocTargetDiv.innerHTML.includes("Critical Error")) {
          tocTargetDiv.innerHTML = '<p>Loading Table of Contents...</p>'; 
        }
        if (searchInput) searchInput.disabled = false;
        const themeToggleButtonInit = document.getElementById('theme-toggle-btn');
        if (themeToggleButtonInit) themeToggleButtonInit.disabled = false;
          
          // ----- Start: TOC and Initial Page Load Logic -----
          if (tocTargetDiv) {
            fetch('toc.html')
              .then(response => {
                if (!response.ok) {
                  throw new Error('Network response was not ok for toc.html: ' + response.status + ' ' + response.statusText);
                }
                return response.text();
              })
              .then(html => {
                tocTargetDiv.innerHTML = html;
                tocTargetDiv.addEventListener('click', function(event) {
                  let targetElement = event.target;
                  while (targetElement && targetElement !== this && targetElement.tagName !== 'A') {
                    targetElement = targetElement.parentElement;
                  }
                  if (targetElement && targetElement.tagName === 'A' && targetElement.hasAttribute('href')) {
                    event.preventDefault();
                    const pageUrl = targetElement.getAttribute('href');
                    if (pageUrl) {
                      window.loadContentIntoIframe(pageUrl, targetElement);
                    }
                  }
                });

                // Enhanced initial page load logic
                setTimeout(async () => {
                  console.log('üöÄ Starting initial content load...');
                  
                  // First try URL routing
                  const handled = await handleRouting();
                  if (handled) {
                    console.log('‚úÖ Content loaded via URL routing');
                    return;
                  }
                  
                  // Then try session storage
                  const lastPage = sessionStorage.getItem('currentPage');
                  if (lastPage) {
                    console.log('üîÑ Loading last viewed page:', lastPage);
                    const success = await window.loadContent(lastPage, null);
                    if (success) {
                      console.log('‚úÖ Content loaded from session storage');
                      return;
                    }
                  }
                  
                  // Try to find introduction link in TOC
                  const introLink = document.querySelector('#dynamic-toc-content a[href*="introduction/page.html"]');
                  if (introLink && introLink.href) {
                    console.log('üîÑ Loading introduction from TOC');
                    window.loadContentIntoIframe(introLink.getAttribute('href'), introLink);
                    return;
                  }
                  
                  // Fallback to hardcoded introduction page
                  console.log('üîÑ Loading fallback introduction page');
                  const success = await window.loadContent('EXPRESS/introduction/page.html', null);
                  if (success) {
                    console.log('‚úÖ Fallback introduction loaded');
                    return;
                  }
                  
                  // Last resort - try any working page
                  const fallbackPages = [
                    'EXPRESS/section/page.html',
                    'EXPRESS/career/index.html',
                    'EXPRESS/comprehensive-storage-test/index.html'
                  ];
                  
                  for (const page of fallbackPages) {
                    console.log('üîÑ Trying fallback page:', page);
                    const success = await window.loadContent(page, null);
                    if (success) {
                      console.log('‚úÖ Fallback page loaded:', page);
                      return;
                    }
                  }
                  
                  // If all else fails, show a helpful message
                  console.warn('‚ö†Ô∏è No content could be loaded, showing help message');
                  const homeContentDiv = document.getElementById('home-content');
                  if (homeContentDiv) {
                    homeContentDiv.innerHTML = `
                      <div style="padding: 40px; text-align: center; font-family: Arial, sans-serif;">
                        <h2>Welcome to TEST_PROJECT</h2>
                        <p>Click any item in the Table of Contents on the left to view content.</p>
                        <button onclick="location.reload()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Refresh Page</button>
                      </div>
                    `;
                  }
                }, 100); // Short delay to ensure TOC is loaded
              })
              .catch(error => {
                console.error('Error loading Table of Contents:', error);
                if (tocTargetDiv) {
                   tocTargetDiv.innerHTML = '<p style="color: red;">Error loading Table of Contents. Details: ' + error.message + '</p>';
                }
                 // If TOC fails, home content should also reflect an error or stop
                if (homeContentDiv) homeContentDiv.innerHTML = '<p style="padding:20px; color:red;">Content loading suspended due to TOC error.</p>';
              });
          } else {
            console.error('Error: Target div for ToC (dynamic-toc-content) not found.');
            showFatalError('UI component for Table of Contents is missing.');
          }
          // ----- End: TOC and Initial Page Load Logic -----

      }
      
      // Run initialization
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadConfigAndInitialize);
      } else {
        // DOMContentLoaded has already fired, run now.
        // This path might be taken if this script itself is deferred or placed very late.
        loadConfigAndInitialize();
      }

      // Add QC Modal functionality
      document.addEventListener('DOMContentLoaded', function() {
        const qcButton = document.getElementById('qc-button');
        const qcModal = document.getElementById('qc-modal');
        const qcCloseButton = document.getElementById('qc-close-button');
        
        if (qcButton && qcModal && qcCloseButton) {
          // Open modal when button is clicked
          qcButton.addEventListener('click', function() {
            qcModal.style.display = 'flex';
            // Run QC if not already done
            if (window.qualityController) {
              runQualityCheck();
            }
          });
          
          // Close modal when X is clicked
          qcCloseButton.addEventListener('click', function() {
            qcModal.style.display = 'none';
          });
          
          // Close modal when clicking outside
          qcModal.addEventListener('click', function(e) {
            if (e.target === qcModal) {
              qcModal.style.display = 'none';
            }
          });
          
          // Close modal with Escape key
          document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && qcModal.style.display === 'flex') {
              qcModal.style.display = 'none';
            }
          });
        }
      });        // Enhanced global error handler to prevent script execution errors from breaking the app
        window.addEventListener('error', function(event) {
            const errorMsg = event.message || '';
            const fileName = event.filename || '';
            
            // Suppress "Unexpected token '<'" errors (HTML being executed as JS)
            if (errorMsg.includes('Unexpected token') || errorMsg.includes('Unexpected end of input')) {
              console.warn('üîá Suppressed script execution error:', errorMsg, 'at', fileName, event.lineno);
              event.preventDefault();
              return true;
            }
            
            // Additional suppression for iframe-related script errors
            if (errorMsg.includes('Script error') && fileName.includes('about:blank')) {
              console.warn('üîá Suppressed iframe script error:', errorMsg);
              event.preventDefault();
              return true;
            }
        
        // Suppress cross-origin iframe errors
        if (errorMsg.includes('Script error') || errorMsg.includes('cross-origin')) {
          console.warn('üîá Suppressed cross-origin error:', errorMsg);
          event.preventDefault();
          return true;
        }
        
        // Suppress module loading errors that don't affect functionality
        if (errorMsg.includes('Failed to fetch dynamically imported module') || errorMsg.includes('Loading chunk')) {
          console.warn('üîá Suppressed module loading error:', errorMsg);
          event.preventDefault();
          return true;
        }
        
        // Log other errors normally but don't break the app
        console.error('‚ö†Ô∏è Application error:', errorMsg, 'at', fileName, event.lineno);
        return false;
      });

      // Enhanced promise rejection handler
      window.addEventListener('unhandledrejection', function(event) {
        const reason = event.reason || {};
        const reasonMsg = reason.message || reason.toString();
        
        if (reasonMsg.includes('Loading CSS chunk') || 
            reasonMsg.includes('Loading chunk') ||
            reasonMsg.includes('Failed to fetch dynamically imported module')) {
          console.warn('üîá Suppressed promise rejection:', reasonMsg);
          event.preventDefault();
          return true;
        }
        
        console.warn('‚ö†Ô∏è Promise rejection:', reasonMsg);
        return false;
      });

      // Initialize with fallbacks
      initializeWithFallbacks();
    </script>
</body>
</html>
